input float2 inUV;
input float4 inColor;

Texture0 texDiffuse
{
    filter = nearest;
    repeat = clamp;
}

Texture1 texNormal
{
    filter = nearest;
    repeat = clamp;
}

Texture2 texDepth
{
    filter = nearest;
    repeat = clamp;
}

extern matrix invProjMtx;
extern float SAMPLES;
extern float SCALE;
extern float BIAS;
extern float SAMPLE_RAD;
extern float MAX_DISTANCE;
extern float INTENSITY;

const float3 MOD3 = float3(0.1031, 0.11369, 0.13787);

float3 getPosition(float2 uv)
{
    float depth = texDepth(uv).r;
    float4 position = float4(float2(uv.x, 1 - uv.y) * 2.0 - 1.0, depth, 1.0);
    position = mul(position, invProjMtx);
    return position.xyz / position.w;
}

float doAmbientOcclusion(float2 tcoord, float2 uv, float3 p, float3 cnorm)
{
    float3 diff = getPosition(tcoord + uv) - p;
    float l = length(diff);
    float3 v = diff / l;
    float d = l * SCALE;
    float ao = max(0.0, dot(cnorm, v) - BIAS) * (1.0 / (1.0 + d));
    ao *= smoothstep(MAX_DISTANCE, MAX_DISTANCE * 0.5, l);
    return ao;
}

float hash12(float2 p)
{
    float3 p3 = frac(float3(p.xyx) * MOD3);
    p3 += dot(p3, p3.yzx + 19.19);
    return frac((p3.x + p3.y) * p3.z);
}

float spiralAO(float2 uv, float3 p, float3 n, float rad)
{
    float goldenAngle = 2.4;
    float ao = 0.0;
    float inv = 1.0 / SAMPLES;
    float radius = 0.0;

    float rotatePhase = hash12(uv * 100.0) * 6.28;
    float rStep = inv * rad;
    float2 spiralUV;

    for (float i = 0.0; i < SAMPLES; i++)
    {
        spiralUV.x = sin(rotatePhase);
        spiralUV.y = cos(rotatePhase);
        radius += rStep;
        ao += doAmbientOcclusion(uv, spiralUV * radius, p, n);
        rotatePhase += goldenAngle;
    }
    ao *= inv;
    return ao;
}

void main()
{
    float4 tdiffuse = texDiffuse(inUV);
    float4 tnormal = texNormal(inUV);

    // Position
    float3 position = getPosition(inUV);

    // normal
    float3 normal = tnormal.xyz * 2.0 - 1.0;

    float rad = SAMPLE_RAD;
    float ao = spiralAO(inUV, position.xyz, normal, rad);
    ao *= INTENSITY;

    oColor = float4(0.0, 0.0, 0.0, ao * tdiffuse.a);
}
